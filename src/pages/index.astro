---
import Layout from '../layouts/Layout.astro';
---

<Layout title="DrawCanvas - Drawing Tool">
  <main class="min-h-screen bg-background">
    <div class="flex flex-col h-[calc(100vh-4rem)]">
      <!-- Toolbar -->
      <div id="toolbar" class="bg-card border-b border-border p-4 flex flex-wrap items-center gap-4">
        <!-- Pencil Tool -->
        <button id="pencilBtn" class="px-4 py-2 bg-primary text-primary-foreground rounded-lg font-medium hover:opacity-90 transition-opacity">
          Pencil
        </button>
        
        <!-- Eraser Tool -->
        <button id="eraserBtn" class="px-4 py-2 bg-secondary text-secondary-foreground rounded-lg font-medium hover:bg-accent transition-colors hidden">
          Eraser
        </button>
        
        <!-- Size Control -->
        <div class="flex items-center gap-2">
          <label for="sizeSlider" class="text-sm text-muted-foreground">Size:</label>
          <input type="range" id="sizeSlider" min="1" max="50" value="5" class="w-32" />
          <span id="sizeValue" class="text-sm text-foreground w-8">5</span>
        </div>
        
        <!-- Color Picker -->
        <div id="colorPicker" class="flex items-center gap-2">
          <label class="text-sm text-muted-foreground">Color:</label>
          <div id="colorButtons" class="flex gap-2"></div>
        </div>
        
        <!-- Clear Button -->
        <button id="clearBtn" class="ml-auto px-4 py-2 bg-secondary text-secondary-foreground rounded-lg font-medium hover:bg-accent transition-colors">
          Clear Canvas
        </button>
        
        <!-- Background Opacity -->
        <div id="opacityControl" class="flex items-center gap-2 hidden">
          <label for="opacitySlider" class="text-sm text-muted-foreground">BG Opacity:</label>
          <input type="range" id="opacitySlider" min="0" max="100" value="50" class="w-32" />
          <span id="opacityValue" class="text-sm text-foreground w-8">50%</span>
        </div>
      </div>
      
      <!-- Canvas Container -->
      <div class="flex-1 relative overflow-hidden">
        <canvas id="backgroundCanvas" class="absolute inset-0"></canvas>
        <canvas id="drawingCanvas" class="absolute inset-0 cursor-crosshair"></canvas>
      </div>
    </div>
  </main>
</Layout>

<script>
  // Parse URL parameters
  const urlParams = new URLSearchParams(window.location.search);
  const sizeParam = urlParams.get('size');
  const colorsParam = urlParams.get('colors');
  const eraserParam = urlParams.get('eraser');
  const bgImageParam = urlParams.get('bgImage');
  const bgOpacityParam = urlParams.get('bgOpacity');

  // Canvas setup
  const drawingCanvas = document.getElementById('drawingCanvas') as HTMLCanvasElement;
  const backgroundCanvas = document.getElementById('backgroundCanvas') as HTMLCanvasElement;
  const drawingCtx = drawingCanvas.getContext('2d')!;
  const backgroundCtx = backgroundCanvas.getContext('2d')!;

  function resizeCanvas() {
    const container = drawingCanvas.parentElement!;
    drawingCanvas.width = container.clientWidth;
    drawingCanvas.height = container.clientHeight;
    backgroundCanvas.width = container.clientWidth;
    backgroundCanvas.height = container.clientHeight;
    
    // Redraw background if exists
    if (bgImageParam) {
      loadBackgroundImage();
    }
  }

  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Drawing state
  let isDrawing = false;
  let currentColor = '#ffffff';
  let currentSize = parseInt(sizeParam || '5');
  let currentTool = 'pencil';
  let bgOpacity = parseInt(bgOpacityParam || '50') / 100;

  // Available colors
  const defaultColors = ['#ffffff', '#000000', '#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899'];
  let availableColors: string[] = [];

  if (colorsParam === '*') {
    availableColors = defaultColors;
  } else if (colorsParam) {
    availableColors = colorsParam.split(',').map(c => c.trim());
  } else {
    availableColors = defaultColors;
  }

  // Setup color buttons
  const colorButtons = document.getElementById('colorButtons')!;
  availableColors.forEach((color, index) => {
    const btn = document.createElement('button');
    btn.className = 'w-8 h-8 rounded-lg border-2 border-border hover:scale-110 transition-transform';
    btn.style.backgroundColor = color;
    btn.onclick = () => {
      currentColor = color;
      currentTool = 'pencil';
      updateToolButtons();
    };
    if (index === 0) {
      btn.classList.add('ring-2', 'ring-primary');
      currentColor = color;
    }
    colorButtons.appendChild(btn);
  });

  // Show/hide eraser based on URL param
  const eraserBtn = document.getElementById('eraserBtn')!;
  if (eraserParam === 'true') {
    eraserBtn.classList.remove('hidden');
  }

  // Tool buttons
  const pencilBtn = document.getElementById('pencilBtn')!;
  pencilBtn.onclick = () => {
    currentTool = 'pencil';
    updateToolButtons();
  };

  eraserBtn.onclick = () => {
    currentTool = 'eraser';
    updateToolButtons();
  };

  function updateToolButtons() {
    if (currentTool === 'pencil') {
      pencilBtn.classList.add('bg-primary', 'text-primary-foreground');
      pencilBtn.classList.remove('bg-secondary', 'text-secondary-foreground');
      eraserBtn.classList.remove('bg-primary', 'text-primary-foreground');
      eraserBtn.classList.add('bg-secondary', 'text-secondary-foreground');
    } else {
      eraserBtn.classList.add('bg-primary', 'text-primary-foreground');
      eraserBtn.classList.remove('bg-secondary', 'text-secondary-foreground');
      pencilBtn.classList.remove('bg-primary', 'text-primary-foreground');
      pencilBtn.classList.add('bg-secondary', 'text-secondary-foreground');
    }
  }

  // Size slider
  const sizeSlider = document.getElementById('sizeSlider') as HTMLInputElement;
  const sizeValue = document.getElementById('sizeValue')!;
  sizeSlider.value = currentSize.toString();
  sizeValue.textContent = currentSize.toString();

  sizeSlider.oninput = () => {
    currentSize = parseInt(sizeSlider.value);
    sizeValue.textContent = currentSize.toString();
  };

  // Opacity slider
  const opacitySlider = document.getElementById('opacitySlider') as HTMLInputElement;
  const opacityValue = document.getElementById('opacityValue')!;
  const opacityControl = document.getElementById('opacityControl')!;

  if (bgImageParam) {
    opacityControl.classList.remove('hidden');
    opacitySlider.value = (bgOpacity * 100).toString();
    opacityValue.textContent = `${Math.round(bgOpacity * 100)}%`;
  }

  opacitySlider.oninput = () => {
    bgOpacity = parseInt(opacitySlider.value) / 100;
    opacityValue.textContent = `${opacitySlider.value}%`;
    loadBackgroundImage();
  };

  // Clear button
  const clearBtn = document.getElementById('clearBtn')!;
  clearBtn.onclick = () => {
    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
  };

  // Load background image
  function loadBackgroundImage() {
    if (!bgImageParam) return;
    
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      backgroundCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
      backgroundCtx.globalAlpha = bgOpacity;
      
      // Calculate scaling to cover canvas
      const scale = Math.max(
        backgroundCanvas.width / img.width,
        backgroundCanvas.height / img.height
      );
      const x = (backgroundCanvas.width - img.width * scale) / 2;
      const y = (backgroundCanvas.height - img.height * scale) / 2;
      
      backgroundCtx.drawImage(img, x, y, img.width * scale, img.height * scale);
      backgroundCtx.globalAlpha = 1;
    };
    img.src = bgImageParam;
  }

  loadBackgroundImage();

  // Drawing functions
  let lastX = 0;
  let lastY = 0;

  function startDrawing(e: MouseEvent | Touch) {
    isDrawing = true;
    const rect = drawingCanvas.getBoundingClientRect();
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;
  }

  function draw(e: MouseEvent | Touch) {
    if (!isDrawing) return;

    const rect = drawingCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    drawingCtx.beginPath();
    drawingCtx.moveTo(lastX, lastY);
    drawingCtx.lineTo(x, y);
    
    if (currentTool === 'eraser') {
      drawingCtx.globalCompositeOperation = 'destination-out';
      drawingCtx.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      drawingCtx.globalCompositeOperation = 'source-over';
      drawingCtx.strokeStyle = currentColor;
    }
    
    drawingCtx.lineWidth = currentSize;
    drawingCtx.lineCap = 'round';
    drawingCtx.lineJoin = 'round';
    drawingCtx.stroke();

    lastX = x;
    lastY = y;
  }

  function stopDrawing() {
    isDrawing = false;
  }

  // Mouse events
  drawingCanvas.addEventListener('mousedown', (e) => startDrawing(e));
  drawingCanvas.addEventListener('mousemove', (e) => draw(e));
  drawingCanvas.addEventListener('mouseup', stopDrawing);
  drawingCanvas.addEventListener('mouseout', stopDrawing);

  // Touch events
  drawingCanvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    startDrawing(e.touches[0]);
  });

  drawingCanvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    draw(e.touches[0]);
  });

  drawingCanvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    stopDrawing();
  });
</script>
